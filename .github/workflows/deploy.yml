name: Deploy to AWS (ECS dev)

on:
  workflow_dispatch:

env:
  AWS_REGION: eu-central-1

jobs:
  build-and-test:
    name: Build & Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dev dependencies
        run: pip install -r requirements-dev.txt

      - name: Run unit tests
        run: pytest tests/ -v --tb=short

  deploy-ecs:
    name: Deploy to ECS (dev)
    runs-on: ubuntu-latest
    needs: build-and-test
    # environment: dev
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required repo variables
        env:
          ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
          ECS_SERVICE: ${{ vars.ECS_SERVICE }}
          ECS_CONTAINER_NAME: ${{ vars.ECS_CONTAINER_NAME }}
          ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
        run: |
          set -euo pipefail
          for v in ECS_CLUSTER ECS_SERVICE ECS_CONTAINER_NAME ECR_REPOSITORY; do
            if [ -z "${!v:-}" ]; then
              echo "::error::Missing repository variable: $v"
              exit 1
            fi
          done

      - name: Validate Dockerfile exists
        run: |
          set -euo pipefail
          if [ ! -f Dockerfile ]; then
            echo "::error::Dockerfile fehlt im Repo-Root. Bitte hinzufügen, bevor Deploy läuft."
            exit 1
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push image
        id: image
        env:
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
        run: |
          set -euo pipefail
          IMAGE_TAG=${GITHUB_SHA::7}
          IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}:${IMAGE_TAG}"
          echo "Building ${IMAGE_URI}"
          docker build -t "${IMAGE_URI}" .
          docker push "${IMAGE_URI}"
          echo "image_uri=${IMAGE_URI}" >> "$GITHUB_OUTPUT"

      - name: Register new task definition revision
        id: taskdef
        env:
          ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
          ECS_SERVICE: ${{ vars.ECS_SERVICE }}
          ECS_CONTAINER_NAME: ${{ vars.ECS_CONTAINER_NAME }}
          IMAGE_URI: ${{ steps.image.outputs.image_uri }}
        run: |
          set -euo pipefail
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster "$ECS_CLUSTER" \
            --services "$ECS_SERVICE" \
            --query 'services[0].taskDefinition' \
            --output text)

          aws ecs describe-task-definition \
            --task-definition "$TASK_DEF_ARN" \
            --query 'taskDefinition' > taskdef.json

          jq --arg CONTAINER "$ECS_CONTAINER_NAME" --arg IMAGE "$IMAGE_URI" '
            del(
              .taskDefinitionArn,
              .revision,
              .status,
              .requiresAttributes,
              .compatibilities,
              .registeredAt,
              .registeredBy
            )
            | .containerDefinitions = (
                .containerDefinitions
                | map(if .name == $CONTAINER then .image = $IMAGE else . end)
              )
          ' taskdef.json > taskdef-new.json

          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://taskdef-new.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "task_def_arn=${NEW_TASK_DEF_ARN}" >> "$GITHUB_OUTPUT"

      - name: Deploy to ECS service
        env:
          ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
          ECS_SERVICE: ${{ vars.ECS_SERVICE }}
          TASK_DEF_ARN: ${{ steps.taskdef.outputs.task_def_arn }}
        run: |
          set -euo pipefail
          aws ecs update-service \
            --cluster "$ECS_CLUSTER" \
            --service "$ECS_SERVICE" \
            --task-definition "$TASK_DEF_ARN" \
            --force-new-deployment

      - name: Wait for service stability
        env:
          ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
          ECS_SERVICE: ${{ vars.ECS_SERVICE }}
        run: |
          set -euo pipefail
          aws ecs wait services-stable \
            --cluster "$ECS_CLUSTER" \
            --services "$ECS_SERVICE"

      - name: Smoke-Test /health
        env:
          SERVICE_HEALTH_URL: ${{ vars.SERVICE_HEALTH_URL }}
        run: |
          set -euo pipefail

          if [ -z "${SERVICE_HEALTH_URL:-}" ]; then
            echo "::notice::SERVICE_HEALTH_URL ist leer/nicht gesetzt. Smoke-Test wird übersprungen."
            echo "- Smoke-Test: ⏭️ übersprungen (SERVICE_HEALTH_URL nicht gesetzt)" >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          echo "Smoke-Test gegen ${SERVICE_HEALTH_URL}"
          HTTP_CODE=$(curl -sS -L \
            --max-time 15 \
            --retry 5 \
            --retry-delay 5 \
            --retry-connrefused \
            -o /tmp/smoke-health-response.txt \
            -w "%{http_code}" \
            "${SERVICE_HEALTH_URL}")

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Smoke-Test fehlgeschlagen: ${SERVICE_HEALTH_URL} lieferte HTTP ${HTTP_CODE}"
            echo "Antwort (gekürzt):"
            head -c 1000 /tmp/smoke-health-response.txt || true
            exit 1
          fi

          echo "Smoke-Test erfolgreich: ${SERVICE_HEALTH_URL} (HTTP ${HTTP_CODE})"
          echo "- Smoke-Test: ✅ ${SERVICE_HEALTH_URL} (HTTP ${HTTP_CODE})" >> "$GITHUB_STEP_SUMMARY"

      - name: Deployment summary
        run: |
          cat <<EOF >> "$GITHUB_STEP_SUMMARY"
          ## ECS Deploy (dev)
          - Cluster: `${{ vars.ECS_CLUSTER }}`
          - Service: `${{ vars.ECS_SERVICE }}`
          - Container: `${{ vars.ECS_CONTAINER_NAME }}`
          - Image: `${{ steps.image.outputs.image_uri }}`
          - TaskDef: `${{ steps.taskdef.outputs.task_def_arn }}`
          EOF
