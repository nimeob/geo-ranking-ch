name: Deploy to AWS (ECS dev)

on:
  workflow_dispatch:
  schedule:
    # Every hour at minute 7 (UTC) to avoid top-of-hour congestion.
    - cron: "7 * * * *"

permissions:
  contents: read
  id-token: write
  issues: write

concurrency:
  group: deploy-ecs-dev
  cancel-in-progress: false

env:
  AWS_REGION: eu-central-1

jobs:
  build-and-test:
    name: Build & Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dev dependencies
        run: pip install -r requirements-dev.txt

      - name: Run unit tests
        run: pytest tests/ -v --tb=short

  deploy-ecs-full-env:
    name: "Deploy full ECS environment (dev: API + UI)"
    runs-on: ubuntu-latest
    needs: build-and-test
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required repo variables
        env:
          ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
          ECS_API_SERVICE: ${{ vars.ECS_API_SERVICE }}
          ECS_UI_SERVICE: ${{ vars.ECS_UI_SERVICE }}
          ECS_API_CONTAINER_NAME: ${{ vars.ECS_API_CONTAINER_NAME }}
          ECS_UI_CONTAINER_NAME: ${{ vars.ECS_UI_CONTAINER_NAME }}
          ECR_API_REPOSITORY: ${{ vars.ECR_API_REPOSITORY }}
          ECR_UI_REPOSITORY: ${{ vars.ECR_UI_REPOSITORY }}
        run: |
          set -euo pipefail
          for v in \
            ECS_CLUSTER \
            ECS_API_SERVICE \
            ECS_UI_SERVICE \
            ECS_API_CONTAINER_NAME \
            ECS_UI_CONTAINER_NAME \
            ECR_API_REPOSITORY \
            ECR_UI_REPOSITORY; do
            if [ -z "${!v:-}" ]; then
              echo "::error::Missing repository variable: $v"
              exit 1
            fi
          done

      - name: Validate Dockerfiles exist
        run: |
          set -euo pipefail
          [ -f Dockerfile ] || { echo "::error::Missing Dockerfile (API)"; exit 1; }
          [ -f Dockerfile.ui ] || { echo "::error::Missing Dockerfile.ui (UI)"; exit 1; }

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::523234426229:role/swisstopo-dev-github-deploy-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push API/UI images
        id: images
        env:
          ECR_API_REPOSITORY: ${{ vars.ECR_API_REPOSITORY }}
          ECR_UI_REPOSITORY: ${{ vars.ECR_UI_REPOSITORY }}
        run: |
          set -euo pipefail
          IMAGE_TAG="${GITHUB_SHA::7}"
          API_IMAGE_URI="523234426229.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_API_REPOSITORY}:${IMAGE_TAG}"
          UI_IMAGE_URI="523234426229.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_UI_REPOSITORY}:${IMAGE_TAG}"

          echo "Building API image ${API_IMAGE_URI}"
          docker build -t "${API_IMAGE_URI}" .
          docker push "${API_IMAGE_URI}"

          echo "Building UI image ${UI_IMAGE_URI}"
          docker build -f Dockerfile.ui \
            --build-arg APP_VERSION="${IMAGE_TAG}" \
            -t "${UI_IMAGE_URI}" .
          docker push "${UI_IMAGE_URI}"

          echo "api_image_uri=${API_IMAGE_URI}" >> "$GITHUB_OUTPUT"
          echo "ui_image_uri=${UI_IMAGE_URI}" >> "$GITHUB_OUTPUT"

      - name: Register new API/UI task definition revisions
        id: taskdefs
        env:
          ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
          ECS_API_SERVICE: ${{ vars.ECS_API_SERVICE }}
          ECS_UI_SERVICE: ${{ vars.ECS_UI_SERVICE }}
          ECS_API_CONTAINER_NAME: ${{ vars.ECS_API_CONTAINER_NAME }}
          ECS_UI_CONTAINER_NAME: ${{ vars.ECS_UI_CONTAINER_NAME }}
          API_IMAGE_URI: ${{ steps.images.outputs.api_image_uri }}
          UI_IMAGE_URI: ${{ steps.images.outputs.ui_image_uri }}
        run: |
          set -euo pipefail

          register_taskdef () {
            local service="$1"
            local container="$2"
            local image="$3"
            local outvar="$4"

            local app_version="${GITHUB_SHA::7}"
            local git_sha="${GITHUB_SHA}"

            local current_taskdef_arn
            current_taskdef_arn=$(aws ecs describe-services \
              --cluster "$ECS_CLUSTER" \
              --services "$service" \
              --query 'services[0].taskDefinition' \
              --output text)

            aws ecs describe-task-definition \
              --task-definition "$current_taskdef_arn" \
              --query 'taskDefinition' > taskdef.json

            local resolved_container="$container"
            if ! jq -e --arg CONTAINER "$container" '.containerDefinitions | any(.name == $CONTAINER)' taskdef.json >/dev/null; then
              local container_count
              container_count=$(jq '.containerDefinitions | length' taskdef.json)

              if [ "$container_count" -eq 1 ]; then
                resolved_container=$(jq -r '.containerDefinitions[0].name' taskdef.json)
                echo "::warning::Container '$container' not found for service '$service'. Fallback to single taskdef container '$resolved_container'."
              else
                local available_containers
                available_containers=$(jq -r '.containerDefinitions[].name' taskdef.json | paste -sd, -)
                echo "::error::Container '$container' not found for service '$service'. Available containers: ${available_containers}."
                exit 1
              fi
            fi

            jq \
              --arg CONTAINER "$resolved_container" \
              --arg IMAGE "$image" \
              --arg APP_VERSION "$app_version" \
              --arg GIT_SHA "$git_sha" '
              del(
                .taskDefinitionArn,
                .revision,
                .status,
                .requiresAttributes,
                .compatibilities,
                .registeredAt,
                .registeredBy
              )
              | .containerDefinitions = (
                  .containerDefinitions
                  | map(
                      if .name == $CONTAINER then
                        .image = $IMAGE
                        | .environment = (
                            (.environment // [])
                            | map(select(.name != "APP_VERSION" and .name != "GIT_SHA"))
                            + [
                                {"name": "APP_VERSION", "value": $APP_VERSION},
                                {"name": "GIT_SHA", "value": $GIT_SHA}
                              ]
                          )
                      else
                        .
                      end
                    )
                )
            ' taskdef.json > taskdef-new.json

            local resolved_image
            resolved_image=$(jq -r --arg CONTAINER "$resolved_container" '.containerDefinitions[] | select(.name == $CONTAINER) | .image' taskdef-new.json)
            if [ "$resolved_image" != "$image" ]; then
              echo "::error::Taskdef update failed for service '$service' container '$resolved_container' (resolved image: '$resolved_image', expected: '$image')."
              exit 1
            fi

            local new_taskdef_arn
            new_taskdef_arn=$(aws ecs register-task-definition \
              --cli-input-json file://taskdef-new.json \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)

            echo "${outvar}=${new_taskdef_arn}" >> "$GITHUB_OUTPUT"
          }

          register_taskdef "$ECS_API_SERVICE" "$ECS_API_CONTAINER_NAME" "$API_IMAGE_URI" "api_task_def_arn"
          register_taskdef "$ECS_UI_SERVICE" "$ECS_UI_CONTAINER_NAME" "$UI_IMAGE_URI" "ui_task_def_arn"

      - name: Deploy API service and wait for stability
        env:
          ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
          ECS_API_SERVICE: ${{ vars.ECS_API_SERVICE }}
          API_TASK_DEF_ARN: ${{ steps.taskdefs.outputs.api_task_def_arn }}
        run: |
          set -euo pipefail
          aws ecs update-service \
            --cluster "$ECS_CLUSTER" \
            --service "$ECS_API_SERVICE" \
            --task-definition "$API_TASK_DEF_ARN" \
            --force-new-deployment

          aws ecs wait services-stable \
            --cluster "$ECS_CLUSTER" \
            --services "$ECS_API_SERVICE"

      - name: Smoke-Test API /health
        env:
          SERVICE_API_BASE_URL: ${{ vars.SERVICE_API_BASE_URL }}
          SERVICE_HEALTH_URL: ${{ vars.SERVICE_HEALTH_URL }}
        run: |
          set -euo pipefail
          API_HEALTH_URL="${SERVICE_HEALTH_URL:-}"
          if [ -z "${API_HEALTH_URL}" ] && [ -n "${SERVICE_API_BASE_URL:-}" ]; then
            API_HEALTH_URL="${SERVICE_API_BASE_URL%/}/health"
          fi

          if [ -z "${API_HEALTH_URL}" ]; then
            echo "::error::Missing SERVICE_API_BASE_URL or SERVICE_HEALTH_URL for API smoke"
            exit 1
          fi

          HTTP_CODE=$(curl -sS -L \
            --max-time 15 \
            --retry 5 \
            --retry-delay 5 \
            --retry-connrefused \
            -o /tmp/smoke-api-health-response.txt \
            -w "%{http_code}" \
            "${API_HEALTH_URL}")

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::API smoke failed: ${API_HEALTH_URL} returned HTTP ${HTTP_CODE}"
            head -c 1000 /tmp/smoke-api-health-response.txt || true
            exit 1
          fi

      - name: Smoke-Test API /analyze (optional)
        env:
          SERVICE_API_BASE_URL: ${{ vars.SERVICE_API_BASE_URL }}
          SERVICE_API_AUTH_TOKEN: ${{ secrets.SERVICE_API_AUTH_TOKEN }}
        run: |
          set -euo pipefail
          BASE_URL="${SERVICE_API_BASE_URL:-}"
          if [ -z "${BASE_URL}" ]; then
            echo "::notice::SERVICE_API_BASE_URL not set. Analyze smoke skipped."
            echo "- Analyze-Smoke: ⏭️ skipped (SERVICE_API_BASE_URL missing)" >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          if [ -n "${SERVICE_API_AUTH_TOKEN:-}" ]; then
            DEV_BASE_URL="${BASE_URL}" DEV_API_AUTH_TOKEN="${SERVICE_API_AUTH_TOKEN}" SMOKE_OUTPUT_JSON="/tmp/bl18.1-smoke.json" ./scripts/run_remote_api_smoketest.sh
          else
            DEV_BASE_URL="${BASE_URL}" SMOKE_OUTPUT_JSON="/tmp/bl18.1-smoke.json" ./scripts/run_remote_api_smoketest.sh
          fi

      - name: Deploy UI service and wait for stability
        env:
          ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
          ECS_UI_SERVICE: ${{ vars.ECS_UI_SERVICE }}
          UI_TASK_DEF_ARN: ${{ steps.taskdefs.outputs.ui_task_def_arn }}
        run: |
          set -euo pipefail
          aws ecs update-service \
            --cluster "$ECS_CLUSTER" \
            --service "$ECS_UI_SERVICE" \
            --task-definition "$UI_TASK_DEF_ARN" \
            --force-new-deployment

          aws ecs wait services-stable \
            --cluster "$ECS_CLUSTER" \
            --services "$ECS_UI_SERVICE"

      - name: Smoke-Test UI /healthz
        env:
          SERVICE_APP_BASE_URL: ${{ vars.SERVICE_APP_BASE_URL }}
        run: |
          set -euo pipefail
          if [ -z "${SERVICE_APP_BASE_URL:-}" ]; then
            echo "::error::Missing SERVICE_APP_BASE_URL for UI smoke"
            exit 1
          fi

          UI_HEALTH_URL="${SERVICE_APP_BASE_URL%/}/healthz"
          HTTP_CODE=$(curl -sS -L \
            --max-time 15 \
            --retry 5 \
            --retry-delay 5 \
            --retry-connrefused \
            -o /tmp/smoke-ui-health-response.txt \
            -w "%{http_code}" \
            "${UI_HEALTH_URL}")

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::UI smoke failed: ${UI_HEALTH_URL} returned HTTP ${HTTP_CODE}"
            head -c 1000 /tmp/smoke-ui-health-response.txt || true
            exit 1
          fi

      - name: Optional strict split smoke (API + UI routing)
        env:
          SERVICE_API_BASE_URL: ${{ vars.SERVICE_API_BASE_URL }}
          SERVICE_APP_BASE_URL: ${{ vars.SERVICE_APP_BASE_URL }}
        run: |
          set -euo pipefail
          if [ -z "${SERVICE_API_BASE_URL:-}" ] || [ -z "${SERVICE_APP_BASE_URL:-}" ]; then
            echo "::notice::SERVICE_API_BASE_URL/SERVICE_APP_BASE_URL missing. Strict split smoke skipped."
            echo "- BL31 strict smoke: ⏭️ skipped (base URLs missing)" >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          STAMP="$(date -u +%Y%m%dT%H%M%SZ)"
          BL31_API_BASE_URL="${SERVICE_API_BASE_URL}" \
          BL31_APP_BASE_URL="${SERVICE_APP_BASE_URL}" \
          BL31_CORS_ORIGIN="$(python3 -c 'import os,urllib.parse as u; p=u.urlsplit(os.environ["SERVICE_APP_BASE_URL"].strip()); print(f"{p.scheme}://{p.netloc}")')" \
          BL31_STRICT_CORS="1" \
          BL31_OUTPUT_JSON="artifacts/bl31/${STAMP}-github-actions-split-smoke.json" \
          ./scripts/run_bl31_routing_tls_smoke.sh

      - name: Post-deploy verification (version + trace-debug)
        env:
          SERVICE_APP_BASE_URL: ${{ vars.SERVICE_APP_BASE_URL }}
          SERVICE_API_BASE_URL: ${{ vars.SERVICE_API_BASE_URL }}
          SERVICE_HEALTH_URL: ${{ vars.SERVICE_HEALTH_URL }}
          TRACE_DEBUG_EXPECT_ENABLED: ${{ vars.TRACE_DEBUG_ENABLED }}
        run: |
          set -euo pipefail
          mkdir -p artifacts/deploy

          EXPECTED_UI_VERSION="${GITHUB_SHA::7}" \
          TRACE_DEBUG_SMOKE_JSON="/tmp/bl18.1-smoke.json" \
          DEPLOY_VERIFY_OUTPUT_JSON="artifacts/deploy/${GITHUB_SHA::7}-post-deploy-verify.json" \
          python3 scripts/check_deploy_version_trace.py

      - name: Deployment summary
        run: |
          cat <<EOF >> "$GITHUB_STEP_SUMMARY"
          ## ECS Deploy (dev) — full environment
          - Cluster: `${{ vars.ECS_CLUSTER }}`
          - API Service: `${{ vars.ECS_API_SERVICE }}`
          - UI Service: `${{ vars.ECS_UI_SERVICE }}`
          - API Container: `${{ vars.ECS_API_CONTAINER_NAME }}`
          - UI Container: `${{ vars.ECS_UI_CONTAINER_NAME }}`
          - API Image: `${{ steps.images.outputs.api_image_uri }}`
          - UI Image: `${{ steps.images.outputs.ui_image_uri }}`
          - API TaskDef: `${{ steps.taskdefs.outputs.api_task_def_arn }}`
          - UI TaskDef: `${{ steps.taskdefs.outputs.ui_task_def_arn }}`
          EOF

  open-or-update-failure-issue:
    name: Open/Update deployment failure issue
    runs-on: ubuntu-latest
    needs: [build-and-test, deploy-ecs-full-env]
    if: ${{ failure() }}
    steps:
      - name: Open or update issue for failed deploy
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const title = 'CI: stündlicher Dev-Deploy fehlgeschlagen';
            const runUrl = `${context.serverUrl}/${owner}/${repo}/actions/runs/${context.runId}`;
            const bodyAppend = [
              `Neuer fehlgeschlagener Lauf: ${runUrl}`,
              '',
              `- Workflow: ${context.workflow}`,
              `- Event: ${context.eventName}`,
              `- Branch/Ref: ${context.ref}`,
              `- SHA: ${context.sha}`,
              `- UTC: ${new Date().toISOString()}`,
              '',
              'Bitte Root-Cause analysieren und fixen, dann Redeploy triggern.'
            ].join('\n');

            const { data: existing } = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              per_page: 100,
            });

            const match = existing.find((i) => i.title === title);

            if (match) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: match.number,
                body: bodyAppend,
              });
              core.info(`Updated existing issue #${match.number}`);
            } else {
              const { data: issue } = await github.rest.issues.create({
                owner,
                repo,
                title,
                body: [
                  'Der automatische Dev-Deploy ist fehlgeschlagen.',
                  '',
                  bodyAppend,
                  '',
                  '## DoD',
                  '- [ ] Fehlerursache identifiziert',
                  '- [ ] Fix auf `main`',
                  '- [ ] Redeploy grün',
                ].join('\n'),
              });
              core.info(`Created issue #${issue.number}`);
            }
